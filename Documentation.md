=========================================================                              
                   DATABASE-INTEGRATION                              
=========================================================

Krav för G:
- Följ instruktionerna i beskrivningen
- Använd Git för versionshantering
- Använd PostgreSQL som databas

Krav för VG:
- Uppnå alla krav för G
- Spara kontoinformation på ett säkert sätt (hashing av lösenord)
- Använd SQL JOINS för data hämtning när det går
- Använd minst två SQL TRANSACTIONS
- Använd alla normalformer (1NF, 2NF, 3NF)
- Felhantera alla databasoperationer (try/catch, resource releasing, using)

Beskrivning
Fortsätt på Personal Finance projektet från förra kursen. Det är okej att skriva om projektet från scratch om det känns enklare med kommande uppgifter.

Applikationen skall koppla på och använda en databas för att spara och hantera information. Alla transaktioner skall sparas och hämtas och raderas och uppdateras till/från databas. Det skall även finnas ett kontosystem, med vilket man kan logga in på olika användare, byta mellan dem och lägga till transaktioner. All funktionalitet som fanns i uppgiften från förra kursen skall finnas nu, men kan skall kunna göra det per-användare. En användare kan inte se transaktioner för en annan användare.


Förtydligande krav för kontosystem, följande möjligheter skall finnas:
- Registrera användare genom namn och lösenord
- Logga in genom namn och lösenord
- Logga ut (och kunna byta användare genom att logga in igen)
- All funktionalitet från tidigare uppgift, kopplat per-användare


=========================================================
               EGNA TANKAR INFÖR UPPGIFTEN                            
=========================================================

Siktar på att uppnå samtliga krav för VG men vill inte fokusera för mycket tid på just detta projekt då jag vill testa lite egna projekt från grund när jag blir färdig. Därför kommer jag att göra val baserat på vad som faktiskt behövs göras och kanske inte på att förbättra programmet mer än nödvändigt. Fokus är på lärande inom ramen för uppgift-specifikationen, inte utanför. 


=========================================================
              QUESTIONS AND CONSIDERATIONS 
=========================================================

Should I have UUID for my user_id and tx_id, or just use SERIAL?
  - SERIAL: Simpler, easier to read, may be more appropriate for my application.
  - UUID: Better security, more common in professional environs, good practice.

Should I explicitly call the reader.Close() instead of just relying on the 'using'?
 - Probably not, unless more complex logic is introduced - instead, implement IDisposable.


=========================================================
                     DOCUMENTATION                                    
=========================================================
SATURDAY, NOVEMBER 23

Added Npgsql.
New class DatabaseManager in Services.

Set up connection specs and constructor for dbManager.
    - sql table creation for users.

Experimenting with a wrapper method for the NpgsqlCommand.ExecuteNonQuery-method.
    - Unsure how this will work with SQL-injection. Will be mindful.

Began implementing AddUser method for adding new users to the database.
    - Uses SQL RETURNING to retrieve user_id and created_at(?) (generated by the DB)
Changed User.UserId from string to int (match DB type).

=========================================================
MONDAY, NOVEMBER 25

DatabaseManager.AddUser():
    - Removed created_at from the RETURNING. Not needed immediately and could retrieve it during other operations. E.g. GetUser() or something.
    - Additional error handling: Guard clause Null/WS and TryCatchThrow

Added try/catch to Main for testing AddUser when resolved errors from changing UserId from string to int.

Refactoring UserService (userId)
    - removed LoadUsers' int parsing
    - removed GenerateUserId method and its calling in CreateAccount.
    - added private readonly field _dbManager

Tested Hardcoded username and password. Works with the database.
Added _dbManager instance to Initialize() - keeping it this way unless it is needed in more places across Program, then I might make it a field.

Added BCrypt
    - Fixed CreateAccount to hash password
    - Fixed AuthenticateUser to check against hashedPassword instead
    - Changed User.cs Password to HashedPassword

=========================================================
WEDNESDAY, NOVEMBER 27


Changes to DatabaseManager:
  Added SQL string for create transaction_type_enum
  Added SQL string for create transactions table
    - Included ON DELETE CASCADE to preserve referential integrity upon deletion of a user.
 
  Isolated each SQL-command to call their own ExecuteNonQuery()
    - Why? Debugging and maintainability.

  Moved the SQL string commands to be initialized as constant fields.
    - Cleaner constructor, better performance, static and immutable.

  Created InitializeDatabase() to further simplify the constructor
    - Executes the SQL commands
    - Added logging messages (only console.writelines)

=========================================================
FRIDAY, NOVEMBER 29

- Added GetUserByUsername() to DatabaseManager for reading users from the DB through a query.

- Adjusted AuthenticateUser to instead of relying on the Dictionary users (loaded from file)

it now uses the above GetUser method to retrieve the user and let BCrypt verify the inputted 
password against the hashed pw.

Improved DatabaseManager class:
- DatabaseManager.AddUser() - changed from ExecuteReader to ExecuteScalar for RETURNING user_id (single value).
- Implemented IDisposable + added dispose() method.

=========================================================
SATURDAY, NOVEMBER 30

- Changed transaction.cs TransactionId from string to int to match database. Simplicity.
-  working on DatabaseTransactionStorage's LoadTransactionsAsync.

=========================================================
SUNDAY, DECEMBER 1

- Implemented SaveTransactionsAsync for DatabaseTransactionStorage.cs

=========================================================
MONDAY, DECEMBER 2

- Finalized SaveTransactionsAsync for DatabaseTransactionStorage.cs.
  - Added sql-transaction with transaction object through: BeginTransaction, Commit and Rollback.
Renamed:
- DatabaseManager    --> DatabaseService
- TransactionManager --> TransactionService
- UserService        --> UserService

 Removed IIdGenerator.cs and TransactionIdGenerator (SERIAL for now).

=========================================================
TUESDAY, DECEMBER 3

- Removed ITransactionOperations - Replaced by combining ITransactionStorage and TransactionService.

- Refactor TransactionService to use ITransactionStorage:
  Removed:
    - in-memory _transactions list.
    - InitializeTransactions() as the functionality is handled by LoadTransactionsAsync().
  Fixed:
    - AddTransactionAsync()
    - RemoveTransactionAsync()
    - GetCurrentUserTransactionsAsync()
    - GetTransactionCountAsync()
    - GetOrderedTransactionsAsync()
    - CalculateTotalsAsync()
    - GetAccountBalanceAsync()
    - PrepareTransactionsAsync()
    - CreateTransactionAsync()
  Added:
    - Experimented with XML-comments and separators, better class structure.

Updated affected components from modifications to TransactionService.cs:
  - Completely refactored all of the commands. 
  - Decoupled UserService from AddIncome/ExpenseCommands by only injecting UserId instead of the entire UserService.

Changes to ConsoleUI.cs
   Created:
      - ConsoleUI.ClearAndWriteLine()
      - DisplayMenuAndGetChoice():  For use in DisplayTransactionsCommand (and possibly in other places).
      - DisplayToggleViewMessage(): SoC to simplify DisplayTransactionCommand.
      - GetTransactionForRemovalIndex(): Displays transactions with indices for removal and gets user input.
   Updated:
      - ConsoleUI.DisplayError/Success to use Thread.Sleep.
      - DisplayDashboard()

Updated affected components from modifications to TransactionService.cs:
  - Completely refactored all of the commands. 
  - Decoupled UserService from AddIncome/ExpenseCommands by only injecting UserId instead of the entire UserService.

Changes to Program.cs
   Updated:
    - RunMainMenu() to use DisplayMenuAndGetChoice()
    - RunLoginMenu() to use DisplayMenuAndGetChoice()
    - Moved RegisterCommands() method to CommandManager and added InitializeCommands() in Program instead: Cleaner Program.



=========================================================
WEDNESDAY, DECEMBER 4
- Updated LoginManager to work with the new TransactionService.
- Added a new constructor to Transaction.cs for excluding TransactionId.
  
- Disabled FileStorage part of the program for now
  Reason: Due to overreaching with my refactoring in preparation for database-integration 
          without sufficient testing there were multiple issues with the current combination
          of FileStorage and DatabaseStorage.

- Removed ITransactionStorage implementation from FileTransactionStorage (for now)
- Removed file saving features of SignOut() - now only resets: CurrentUser = null.

=========================================================
THURSDAY, DECEMBER 5

- Updated HandleSignOut() to align with SignOut().
- Updated HandleCreateAccount() to not include file operations.
- Completely removed FileManager.cs and references.
- Refactored and updated LoginManager.
- Removed SaveAndExit() from Program.cs - was being used for file-saving.
- SQL: Changed from custom enum type column to TEXT with CHECK for simplicity --> updated CreateTransactionsTableSql()
- Removed FileTransactionStorage.
- Removed ITransactionUIOperations.


=========================================================
FRIDAY, DECEMBER 6

- Switched time-based in-memory logic to SQL logic for:
- PrepareTransactionDataAsync() renamed --> GetGroupedTransactionsAsync().
- Changed TransactionSummary's dictionary (GroupedTransactions) to be of 
  type DateTime instead of string.
- Updated FormatGroupKey to work with change above and also recreated it into a switch-expression 
- based on different timeUnits.

- Removed outdated PrepareTransactionDataAsync logic and replaced it with a new SQL-based approach in 
  GetGroupedTransactionsAsync.
- Implemented dynamic SQL GROUP BY queries to handle grouping of transactions by Day, Week, Month, and Year.
- Ensured TransactionSummary is populated with both GroupedTransactions and a flat Transactions list 
  for consistent handling in the UI.
- Debugged and enhanced DisplayTransactionsByIndividual using existing TransactionDateHelper methods,
  ensuring group keys are formatted correctly based on the selected time unit.
- Tested and confirmed functionality for transaction grouping, display, and summaries.



=========================================================
TESTING & DEBUGGING
  To remove:
    Commands: constructor checks
    CommandManager: Logging around each command.
    [DEBUG] D1 command registered successfully.
    [DEBUG] D2 command registered successfully.
    [DEBUG] D3 command registered successfully.

=========================================================
TODO - NEXT:
- Verify SQL JOIN:
    Review the code for opportunities to use SQL JOIN where multiple tables are involved 
    (e.g., linking transactions to user accounts).

=========================================================
TODO - FULL:
- Refactor the transaction storage system to prioritize 
  database storage while keeping file storage as a backup or 
  optional feature.
 - Update the flow so the program doesn't require a file to exist if 
  the database is being used.
- Check SQLTransactions ACID. Rollback()
- check out vertical slice architecture for folder/file structure
- Do I need the transactionId in Transaction.cs constructor?
- Introduce/generate UUID?

- Implement SQL Transactions:
    At least two SQL transactions need to be added. For example:
        Batch insertion or deletion of transactions.
        Account deletion cascading through user data.

- Check RemoveTransactionCommand, implement SQL command for it.

- Test for Edge Cases:
    Ensure robust behavior for:
        Empty transaction lists.
        Invalid input or database states.
        Large datasets.

- Final Review and Cleanup:

    Ensure redundant or unused code is removed.
    Double-check for consistent UI and error handling.